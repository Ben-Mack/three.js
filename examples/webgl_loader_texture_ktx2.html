<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - materials - compressed textures</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl - compressed KTX textures<br />
	<a href="https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/">Khronos Texture</a> is a lightweight file format for OpenGL
</div>

<script type="module">
	import * as THREE from '../build/three.module.js';

	import { KTX2Loader } from './jsm/loaders/KTX2Loader.js';

	var camera, scene, renderer;
	var meshes = [];

	init();
	animate();

	function init() {

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );
		camera.position.z = 1000;

		scene = new THREE.Scene();

		var geometry = new THREE.BoxBufferGeometry( 200, 200, 200 );
		var material1, material2;

		// TODO: add cubemap support
		var loader = new KTX2Loader();

		material1 = new THREE.MeshBasicMaterial( {
			map: loader.load( 'textures/compressed/color_grid_basis.ktx2' )
		} );
		material2 = new THREE.MeshBasicMaterial( {
			map: loader.load( 'textures/compressed/FlightHelmet_baseColor_basis.ktx2' )
		} );

		meshes.push( new THREE.Mesh( geometry, material1 ) );
		meshes.push( new THREE.Mesh( geometry, material2 ) );

		var x = - meshes.length / 2 * 150;
		for ( var i = 0; i < meshes.length; ++ i, x += 300 ) {

			var mesh = meshes[ i ];
			mesh.position.x = x;
			mesh.position.y = 0;
			scene.add( mesh );

		}

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {

		requestAnimationFrame( animate );

		var time = Date.now() * 0.001;

		for ( var i = 0; i < meshes.length; i ++ ) {

			var mesh = meshes[ i ];
			mesh.rotation.x = time;
			mesh.rotation.y = time;

		}

		renderer.render( scene, camera );

	}

</script>

</body>
</html>
